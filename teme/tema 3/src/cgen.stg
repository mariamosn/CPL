sequence(e) ::= "<e; separator=\"\n\">"
sequenceSpaced(e) ::= "<e; separator=\"\n\n\">"

program(constStrs, constInts, classesConstStrNames, prototypesNames, prototypes, dispatchTables, initRoutines, methods, intTag, strTag, boolTag) ::= <<
    .data
    .align  2
    .globl  class_nameTab
    .globl  Int_protObj
    .globl  String_protObj
    .globl  bool_const0
    .globl  bool_const1
    .globl  Main_protObj
    .globl  _int_tag
    .globl  _string_tag
    .globl  _bool_tag

_int_tag:
    .word   <intTag>
_string_tag:
    .word   <strTag>
_bool_tag:
    .word   <boolTag>

<constStrs>
<constInts>
bool_const0:
    .word   <boolTag>
    .word   4
    .word   Bool_dispTab
    .word   0
bool_const1:
    .word   <boolTag>
    .word   4
    .word   Bool_dispTab
    .word   1

class_nameTab:
<classesConstStrNames>

class_objTab:
<prototypesNames>

<prototypes>

<dispatchTables>

    .globl  heap_start
heap_start:
    .word   0
    .text
    .globl  Int_init
    .globl  String_init
    .globl  Bool_init
    .globl  Main_init
    .globl  Main.main

<initRoutines>
<methods>
>>

constStr(orderNum, tag, size, int_len, str) ::= <<
str_const<orderNum>:
    .word   <tag>
    .word   <size>
    .word   String_dispTab
    .word   <int_len>
    .asciiz "<str>"
    .align  2
>>

constInt(orderNum, tag, val) ::= <<
int_const<orderNum>:
    .word   <tag>
    .word   4
    .word   Int_dispTab
    .word   <val>
>>

initClass(className, parentName, attrs) ::= <<
<className>_init:
    addiu   $sp $sp -12
    sw      $fp 12($sp)
    sw      $s0 8($sp)
    sw      $ra 4($sp)
    addiu   $fp $sp 4
    move    $s0 $a0
<if(parentName)>    jal     <parentName>_init
<endif>
<if(attrs)><attrs>
<endif>
    move    $a0 $s0
    lw      $fp 12($sp)
    lw      $s0 8($sp)
    lw      $ra 4($sp)
    addiu   $sp $sp 12
    jr      $ra
>>

methodImpl(className, methodName, body, cntParams) ::= <<
<className>.<methodName>:
    addiu   $sp $sp -12
    sw      $fp 12($sp)
    sw      $s0 8($sp)
    sw      $ra 4($sp)
    addiu   $fp $sp 4
    move    $s0 $a0
<body>
    lw      $fp 12($sp)
    lw      $s0 8($sp)
    lw      $ra 4($sp)
    addiu   $sp $sp 12
    addiu   $sp $sp <cntParams> # params free
    jr      $ra
>>

dispatchImplicit(params, crt, fileName, crtLine, offsetInDispTable) ::= <<
<params>
    move    $a0 $s0
    bnez    $a0 dispatch<crt>
    la      $a0 <fileName>
    li      $t1 <crtLine>
    jal     _dispatch_abort
dispatch<crt>:
    lw      $t1 8($a0)      # dispatch table
    lw      $t1 <offsetInDispTable>($t1)    # method offset
    jalr    $t1
>>

dispatchExplicit(params, dispEntity, crt, fileName, crtLine, atType, offsetInDispTable) ::= <<
<params>
<dispEntity>
    bnez    $a0 dispatch<crt>
    la      $a0 <fileName>
    li      $t1 <crtLine>
    jal     _dispatch_abort
dispatch<crt>:
<if(atType)>
    la      $t1 <atType>_dispTab    # dispatch table
<else>
    lw      $t1 8($a0)  # dispatch table
<endif>
    lw      $t1 <offsetInDispTable>($t1)    # method offset
    jalr    $t1
>>

paramOnStack(parameter) ::= <<
<parameter>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
>>

let(localsSize, vars, body) ::= <<
    addiu   $sp $sp -<localsSize>     # locals alloc
<vars>
<body>
    addiu   $sp $sp <localsSize>    # locals free
>>

localVar(var, offset) ::= <<
<var>
    sw      $a0 -<offset>($fp)
>>

assign(var, expr) ::= <<
<expr>
    sw      $a0 <var>
>>

new(name) ::= <<
    la      $a0 <name>_protObj
    jal     Object.copy
    jal     <name>_init
>>

new_self_type() ::= <<
    la      $t1 class_objTab
    lw      $t2 0($s0)          # class tag
    sll     $t2 $t2 3           # *8
    addu    $t1 $t1 $t2         # class_objTab + 8 * tag
    sw      $t1 0($sp)
    addiu   $sp $sp -4
    lw      $a0 0($t1)          # _protObj
    jal     Object.copy
    lw      $t1 4($sp)
    addiu   $sp $sp 4
    lw      $t1 4($t1)          # _init
    jalr    $t1
>>

if(crt, cond, thenBranch, elseBranch) ::= <<
<cond>
    lw      $t1 12($a0)     # bool slot
    beqz    $t1 else<crt>
<thenBranch>
    b       endif<crt>
else<crt>:
<elseBranch>
endif<crt>:
>>

isVoid(val, crt) ::= <<
<val>
    move    $t1 $a0
    la      $a0 bool_const1
    beqz    $t1 isvoid<crt>
    la      $a0 bool_const0
isvoid<crt>:
>>

not(crt, val) ::= <<
<val>
    lw      $t1 12($a0)     # bool slot
    la      $a0 bool_const1
    beqz    $t1 not<crt>
    la      $a0 bool_const0
not<crt>:
>>

plus(right, left) ::= <<
<left>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
<right>
    jal     Object.copy
    lw      $t1 4($sp)
    addiu   $sp $sp 4
    lw      $t1 12($t1)     # int slot
    lw      $t2 12($a0)     # int slot
    add     $t1 $t1 $t2
    sw      $t1 12($a0)     # int slot
>>

minus(right, left) ::= <<
<left>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
<right>
    jal     Object.copy
    lw      $t1 4($sp)
    addiu   $sp $sp 4
    lw      $t1 12($t1)     # int slot
    lw      $t2 12($a0)     # int slot
    sub     $t1 $t1 $t2
    sw      $t1 12($a0)     # int slot
>>

mult(right, left) ::= <<
<left>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
<right>
    jal     Object.copy
    lw      $t1 4($sp)
    addiu   $sp $sp 4
    lw      $t1 12($t1)     # int slot
    lw      $t2 12($a0)     # int slot
    mul     $t1 $t1 $t2
    sw      $t1 12($a0)     # int slot
>>

div(right, left) ::= <<
<left>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
<right>
    jal     Object.copy
    lw      $t1 4($sp)
    addiu   $sp $sp 4
    lw      $t1 12($t1)     # int slot
    lw      $t2 12($a0)     # int slot
    div     $t1 $t1 $t2
    sw      $t1 12($a0)     # int slot
>>

neg(val) ::= <<
<val>
    jal     Object.copy
    lw      $t1 12($a0)     # int slot
    neg     $t1 $t1
    sw      $t1 12($a0)     # int slot
>>

swLine(offset) ::= <<
    sw      $a0 <offset>($s0)
>>

cmp_eq(left, right, crt) ::= <<
<left>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
<right>
    lw      $t1 4($sp)
    addiu   $sp $sp 4
    move    $t2 $a0
    la      $a0 bool_const1
    beq     $t1 $t2 cmp_eq<crt>
    la      $a1 bool_const0
    jal     equality_test
cmp_eq<crt>:
>>

cmp_lt(left, right, crt) ::= <<
<left>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
<right>
    lw      $t1 4($sp)
    addiu   $sp $sp 4
    lw      $t1 12($t1)     # int slot
    lw      $t2 12($a0)     # int slot
    la      $a0 bool_const1
    blt     $t1 $t2 compare_lt<crt>
    la      $a0 bool_const0
compare_lt<crt>:
>>

cmp_le(left, right, crt) ::= <<
<left>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
<right>
    lw      $t1 4($sp)
    addiu   $sp $sp 4
    lw      $t1 12($t1)     # int slot
    lw      $t2 12($a0)     # int slot
    la      $a0 bool_const1
    ble     $t1 $t2 compare_le<crt>
    la      $a0 bool_const0
compare_le<crt>:
>>

tabLine(content) ::= <<
    <content>
>>

wordLine(name) ::= <<
    .word   <name>
>>

asciiLine(name) ::= <<
    .asciiz <name>
>>

alignLine(name) ::= <<
    .align  <name>
>>

defaultInt() ::= <<
    .word   0
>>

defaultStr() ::= <<

>>

prototype(className, tag, size, attrs) ::= <<
<className>_protObj:
    .word   <tag>
    .word   <size>
    .word   <className>_dispTab<if(attrs)>
<attrs><endif>
>>


literal(value) ::= <<
    la      $a0 <value>
>>

while(crt, cond, body) ::= <<
while<crt>:
<cond>
    lw      $t1 12($a0)     # bool slot
    beqz    $t1 endwhile<crt>
<body>
    b       while<crt>
endwhile<crt>:
    move    $a0 $zero
>>

case(body, crt, fileName, crtLine, caseOpts)::=<<
    addiu   $sp $sp -4   # locals alloc
    move    $s0 $a0
<body>                  #body
    bnez    $a0 case<crt>
    la      $a0 <fileName>
    li      $t1 <crtLine>
    jal     _case_abort2
case<crt>:
    sw      $a0 -4($fp)
    lw      $t1 0($a0)      # class tag
<caseOpts>
    lw      $a0 -4($fp)
    jal     _case_abort
endcase<crt>:
    addiu   $sp $sp 4    # locals free

>>

CaseOpt(tagClass, maxTagChildren, value, crt, crtNext)::=<<
    blt     $t1 <tagClass> casebranch<crtNext>
    bgt     $t1 <maxTagChildren> casebranch<crtNext>
<value>
     b       endcase<crt>
casebranch<crtNext>:

>>

